plugins {
    id 'java'
    id 'com.gradleup.shadow' version '8.3.9'
    id 'jacoco'
}

group = 'com.cliffmin'
version = '0.6.1'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // CLI framework
    implementation libs.picocli
    
    // JSON processing
    implementation libs.gson
    
    // String utilities
    implementation libs.commonsLang3
    
    // Logging
    implementation libs.slf4jSimple

    // HTTP server for daemon
    implementation libs.undertowCore
    implementation libs.undertowWebsocketsJsr

    // Metrics
    implementation libs.micrometerCore
    implementation libs.micrometerPrometheus
    
    // Testing
    testImplementation libs.junitJupiter
    testImplementation libs.junitJupiterEngine
    testImplementation libs.junitPlatformLauncher
    testImplementation libs.junitPlatformSuiteApi
    testImplementation libs.junitPlatformSuiteEngine
    testImplementation libs.assertjCore
    testImplementation libs.mockitoCore
}

// Configure JAR manifest
jar {
    archiveBaseName = 'whisper-post'
    archiveVersion = ''
    manifest {
        attributes(
            'Main-Class': 'com.cliffmin.whisper.WhisperPostProcessorCLI',
            'Implementation-Title': 'Whisper Post Processor',
            'Implementation-Version': version
        )
    }
}

// Shadow JAR for fat JAR with all dependencies (whisper-post)
shadowJar {
    archiveBaseName = 'whisper-post'
    archiveClassifier = ''
    archiveVersion = ''
    mergeServiceFiles()
    manifest {
        attributes 'Main-Class': 'com.cliffmin.whisper.WhisperPostProcessorCLI'
    }
}

// VoxCore CLI fat JAR
task voxcoreJar(type: com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
    archiveBaseName = 'voxcore'
    archiveClassifier = ''
    archiveVersion = ''
    from sourceSets.main.output
    configurations = [project.configurations.runtimeClasspath]
    mergeServiceFiles()
    manifest {
        attributes 'Main-Class': 'com.cliffmin.voxcore.VoxCoreCLI'
    }
}

// Test configuration
// Run unit tests only (exclude integration/slow suites)
test {
    useJUnitPlatform {
        excludeTags 'integration'
    }
    // Exclude known integration/slow test packages and classes by convention
    // Integration package
    filter {
        excludeTestsMatching "com.cliffmin.whisper.integration.*"
        // Common integration/slow class name patterns
        excludeTestsMatching "*IntegrationTest"
        excludeTestsMatching "*Performance*"
        excludeTestsMatching "*Accuracy*"
        excludeTestsMatching "*FullTestSuite*"
    }
    testLogging {
        events "passed", "skipped", "failed"
    }
}

// Integration test configuration
task integrationTest(type: Test) {
    description = 'Run integration tests including E2E pipeline tests'
    group = 'verification'
    
    useJUnitPlatform {
        includeTags 'integration'
    }
    
    // Include integration test classes
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    
    // Run integration tests after unit tests
    shouldRunAfter test
    
    // More verbose output for integration tests
    testLogging {
        events "started", "passed", "skipped", "failed", "standardOut"
        showStandardStreams = true
    }
    
    // Longer timeout for integration tests
    systemProperty 'junit.jupiter.execution.timeout.default', '60s'
}

// Task to run all tests (unit + integration)
task testAll(dependsOn: [test, integrationTest]) {
    description = 'Run all tests (unit and integration)'
    group = 'verification'
}

// Custom task to build a standalone executable
task buildExecutable(type: Copy, dependsOn: shadowJar) {
    from shadowJar
    into 'dist'
    rename { 'whisper-post.jar' }
    doLast {
        println "Executable JAR created: dist/whisper-post.jar"
        println "Run with: java -jar dist/whisper-post.jar"
    }
}

// Task to create a shell wrapper
task createWrapper(dependsOn: shadowJar) {
    doLast {
        def wrapperScript = file('dist/whisper-post')
        wrapperScript.parentFile.mkdirs()
        wrapperScript.text = """#!/bin/bash
# Whisper Post-Processor
SCRIPT_DIR="\$( cd "\$( dirname "\${BASH_SOURCE[0]}" )" && pwd )"
java -jar "\$SCRIPT_DIR/whisper-post.jar" "\$@"
"""
        wrapperScript.setExecutable(true)
        println "Wrapper script created: dist/whisper-post"
    }
}

// Task to build VoxCore CLI executable
task buildVoxCore(type: Copy, dependsOn: voxcoreJar) {
    from voxcoreJar
    into 'dist'
    rename { 'voxcore.jar' }
    doLast {
        println "VoxCore JAR created: dist/voxcore.jar"
        println "Run with: java -jar dist/voxcore.jar"
    }
}

// Task to create VoxCore wrapper script
task createVoxCoreWrapper(dependsOn: voxcoreJar) {
    doLast {
        def wrapperScript = file('dist/voxcore')
        wrapperScript.parentFile.mkdirs()
        wrapperScript.text = """#!/bin/bash
# VoxCore CLI
SCRIPT_DIR="\$( cd "\$( dirname "\${BASH_SOURCE[0]}" )" && pwd )"
java -jar "\$SCRIPT_DIR/voxcore.jar" "\$@"
"""
        wrapperScript.setExecutable(true)
        println "VoxCore wrapper script created: dist/voxcore"
    }
}

// Build everything
task buildAll(dependsOn: [buildExecutable, createWrapper, buildVoxCore, createVoxCoreWrapper]) {
    doLast {
        println ""
        println "================================================"
        println "Build complete!"
        println "================================================"
        println "Whisper Post-Processor: dist/whisper-post"
        println "VoxCore CLI:            dist/voxcore"
        println ""
        println "Test VoxCore:"
        println "  dist/voxcore config validate"
        println "  dist/voxcore config show"
        println "  dist/voxcore transcribe <audio.wav>"
        println "================================================"
    }
}

// Fixture size enforcement (10MB hard limit)
task checkFixtureSize {
    description = 'Verify test fixtures do not exceed size limit'
    group = 'verification'

    doLast {
        def fixturesDir = file('../tests/fixtures')
        if (!fixturesDir.exists()) {
            println "No fixtures directory found - skipping check"
            return
        }

        // Only check committed files (not local artifacts)
        def gitLsFiles = "git ls-files tests/fixtures".execute(null, file('..'))
        gitLsFiles.waitFor()

        if (gitLsFiles.exitValue() != 0) {
            println "Not a git repository or git not available - checking all files"
            // Fallback to checking all files if not in git
            def audioFiles = fileTree(fixturesDir).matching {
                include '**/*.wav', '**/*.mp3', '**/*.m4a'
            }

            def totalSize = 0
            audioFiles.each { file ->
                totalSize += file.length()
            }

            def sizeMB = totalSize / (1024 * 1024)
            println "Test fixtures size: ${String.format('%.2f', sizeMB)} MB (all files)"
            return
        }

        def committedFiles = gitLsFiles.text.split('\n').findAll {
            it.endsWith('.wav') || it.endsWith('.mp3') || it.endsWith('.m4a')
        }

        def totalSize = 0
        committedFiles.each { relativePath ->
            def file = file("../${relativePath}")
            if (file.exists()) {
                totalSize += file.length()
            }
        }

        def sizeMB = totalSize / (1024 * 1024)
        def limitMB = 10

        println "Committed test fixtures: ${committedFiles.size()} files, ${String.format('%.2f', sizeMB)} MB"

        if (sizeMB > limitMB) {
            throw new GradleException(
                "Test fixtures exceed ${limitMB}MB limit (current: ${String.format('%.2f', sizeMB)}MB). " +
                "Remove unnecessary fixtures or regenerate synthetically."
            )
        }

        println "âœ“ Fixtures within ${limitMB}MB limit"
    }
}

// Run fixture check before tests
test.dependsOn checkFixtureSize

// JaCoCo test coverage
jacocoTestReport {
    reports {
        xml.required = true
        html.required = true
    }
}

test.finalizedBy jacocoTestReport
