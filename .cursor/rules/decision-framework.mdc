---
description: Decision framework for classifying and handling tasks
alwaysApply: true
---

# Task Classification & Decision Framework

## Task Classification

### SIMPLE Tasks (< 3 files, obvious solution)
- **Action**: Just do it
- **Examples**: Fix typo, rename variable, add single test case
- **No approval needed**

### COMPLEX Tasks (architectural, multiple approaches, > 3 files)
- **Action**: Enter plan mode or present approach first
- **Show**: 
  - What will change
  - Why this approach
  - Alternative approaches considered
  - Trade-offs
- **Wait for approval** before implementing

### UNCERTAIN Tasks
- **Action**: Ask for clarification
- **Don't assume** - clarify requirements first

## Decision Tagging

When making non-obvious decisions, tag them:

- `[BEST_PRACTICE]` - Following established best practices
- `[CONSTRAINT]` - Required by project architecture/requirements
- `[OPINION]` - Design choice where alternatives exist
- `[TRADEOFF]` - Explicitly choosing one approach over another

## Engineering Principles

1. **Prefer existing patterns** - Don't create new abstractions unless necessary
2. **Stateless core** - Keep core algorithmic and stateless (see architecture.md)
3. **Plugin architecture** - Advanced features go in plugins, not core
4. **No backwards-compat hacks** - Delete unused code completely
5. **Security at boundaries** - Validate inputs at API boundaries, trust internal code
6. **Test comprehensively** - Unit + integration tests for changes

## When in Doubt

- **Ask, don't assume**
- **Default to minimal/safest option** under time pressure
- **Reference project docs** - Check architecture.md, CONTRIBUTING.md, repo-practices.md
